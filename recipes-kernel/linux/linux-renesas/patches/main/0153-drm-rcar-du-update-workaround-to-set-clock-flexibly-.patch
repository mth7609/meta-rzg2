From 5dda2c283365124202963385c1b7a2033b8e4d6e Mon Sep 17 00:00:00 2001
From: Hien Huynh <hien.huynh.px@renesas.com>
Date: Fri, 2 Apr 2021 14:38:25 +0700
Subject: [PATCH 153/180] drm: rcar-du: update workaround to set clock flexibly
 based on video clock

This commit is created to update workaround to set clock flexibly
based on video clock for RZ/G2L with setting:
- Set in rcar-du source if using parallel interface.
- Set in rzg2l-mipi-dsi source if using MIPI DSI interface.

Signed-off-by: Hien Huynh <hien.huynh.px@renesas.com>
---
 drivers/gpu/drm/rcar-du/rcar_du_crtc.c   | 248 +++----------------------------
 drivers/gpu/drm/rcar-du/rcar_du_drv.h    |  94 ++++++++++++
 drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c |   4 +
 3 files changed, 121 insertions(+), 225 deletions(-)

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
index da4147b..e4cfce1 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
@@ -213,193 +213,6 @@ static const struct soc_device_attribute rcar_du_r8a7795_es1[] = {
 	{ /* sentinel */ }
 };
 
-struct cpg_param {
-	u32	frequency;
-	u32	pl5_refdiv;
-	u32	pl5_intin;
-	u32	pl5_fracin;
-	u32	pl5_postdiv1;
-	u32	pl5_postdiv2;
-	u32	pl5_scc_en;
-	u32	pl5_downspread;
-	u32	pl5_divval;
-	u32	pl5_spread;
-	u32	dsi_div_a;
-	u32	dsi_div_b;
-};
-
-#define	TABLE_MAX	11
-#define reg_write(x, a)	iowrite32(a, x)
-#define CPG_LPCLK_DIV	0
-
-struct cpg_param resolution_param[TABLE_MAX] = {
-	{
-		/* VGA 25.175MHz	*/
-		/* frequency		*/	25175,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	16,
-		/* pl5_fracin		*/	13141593,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* VGA 25.200MHz	*/
-		/* frequency		*/	25200,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	16,
-		/* pl5_fracin		*/	13421773,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* 480p 27.000MHz	*/
-		/* frequency		*/	27000,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	18,
-		/* pl5_fracin		*/	0,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* 480p 27.027MHz	*/
-		/* frequency		*/	27027,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	18,
-		/* pl5_fracin		*/	301990,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* WVGA 29.605MHz	*/
-		/* frequency		*/	29605,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	19,
-		/* pl5_fracin		*/	12359216,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* SVGA 40.00MHz	*/
-		/* frequency		*/	40000,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	43,
-		/* pl5_fracin		*/	11184810,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* XGA	65.00MHz	*/
-		/* frequency		*/	65000,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	43,
-		/* pl5_fracin		*/	5592405,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* 720p 74.176MHz	*/
-		/* frequency		*/	74176,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	49,
-		/* pl5_fracin		*/	7560932,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* 720p 74.25MHz	*/
-		/* frequency		*/	74250,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	49,
-		/* pl5_fracin		*/	8388608,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	3,	// 1/4
-	},
-	{
-		/* SXGA 108MHz		*/
-		/* frequency		*/	108000,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	54,
-		/* pl5_fracin		*/	0,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	2,	// 1/3
-	},
-	{
-		/* 1080p 148.5MHz	*/
-		/* frequency		*/	148500,
-		/* pl5_refdiv		*/	1,
-		/* pl5_intin		*/	74,
-		/* pl5_fracin		*/	4194304,
-		/* pl5_postdiv1		*/	1,
-		/* pl5_postdiv2		*/	1,
-		/* pl5_scc_en		*/	1,
-		/* pl5_downspread	*/	1,
-		/* pl5_divval		*/	6,
-		/* pl5_spread		*/	5,
-		/* dsi_div_a		*/	2,	// 1/4
-		/* dsi_div_b		*/	2,	// 1/3
-	},
-};
-
 static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
 {
 	const struct drm_display_mode *mode = &rcrtc->crtc.state->adjusted_mode;
@@ -410,44 +223,21 @@ static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
 
 	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L)) {
 		u32 ditr0, ditr1, ditr2, ditr3, ditr4, ditr5, pbcr0;
-		void __iomem *cpg_base = ioremap_nocache(0x11010000, 0x1000);
-		u32 i, index, prevIndex = 0;
-
-		for (i = 0; i < TABLE_MAX; i++)
-		{
-			if (resolution_param[i].frequency == mode->clock)
-			{
-				index = i;
-				break;
-			}
-			if (resolution_param[i].frequency > mode->clock)
-			{
-				if ((resolution_param[i].frequency - mode->clock) > (mode->clock - resolution_param[prevIndex].frequency))
-				{
-					index = prevIndex;
-				}
-				else
-				{
-					index = i;
-				}
-				break;
-			}
-			prevIndex = i;
-		}
-
-		if (i == TABLE_MAX)
-		{
-			index = TABLE_MAX - 1;
-		}
-
-		reg_write(cpg_base + 0x0204, 0x10000000 | (CPG_LPCLK_DIV<<12)); //CPG_PL2_DDIV: DIV_DSI_LPCLK
-		reg_write(cpg_base + 0x0420, 0x01010000 | (resolution_param[index].dsi_div_a<<0) | (resolution_param[index].dsi_div_b << 8)); //CPG_PL5_SDIV: DIV_DSI_A, DIV_DSI_B
-		reg_write(cpg_base + 0x0144, 0x01110000 | (resolution_param[index].pl5_postdiv1<<0) | (resolution_param[index].pl5_postdiv2<<4) | (resolution_param[index].pl5_refdiv<<8)); //CPG_PLL5_CLK1: POSTDIV1, POSTDIV2, REFDIV
-		reg_write(cpg_base + 0x014C, (resolution_param[index].pl5_divval<<0) | (resolution_param[index].pl5_fracin<<8)); //CPG_PLL5_CLK3: DIVVAL=6, FRACIN
-		reg_write(cpg_base + 0x0150, 0x000000ff | (resolution_param[index].pl5_intin<<16)); //CPG_PLL5_CLK4: INTIN
-		reg_write(cpg_base + 0x0154, (resolution_param[index].pl5_spread<<0)); //CPG_PLL5_CLK5: SPREAD
-		reg_write(cpg_base + 0x0140, 0x00150001 | (resolution_param[index].pl5_scc_en<<2) | (resolution_param[index].pl5_downspread<<4)); //CPG_PLL5_STBY: RESETB=1, SSC_EN, DOWNSPREAD
-		iounmap(cpg_base);
+		struct rcar_du_crtc_state *rstate =
+					to_rcar_crtc_state(rcrtc->crtc.state);
+
+		if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L) &&
+		    rstate->outputs == BIT(RCAR_DU_OUTPUT_DPAD0))
+			/* To be easy for setting, we set hsfreq value based on
+			 * relationship of hsfreq and vclk in MIPI DSI:
+			 * vclk * bpp = hsfreq * data_lanes * 8
+			 * and set default with:
+			 * - bpp = 24
+			 * - data_lanes = 4
+			 * hsfreq will be vclk * 2/3
+			 */
+			pll5_set_rate(mode->clock * 1000,
+				      mode->clock * 750, 1);
 
 		ditr0 = (DU_DITR0_DEMD_HIGH
 		| ((mode->flags & DRM_MODE_FLAG_PVSYNC) ? DU_DITR0_VSPOL : 0)
@@ -1006,7 +796,15 @@ static void rcar_du_crtc_atomic_disable(struct drm_crtc *crtc,
 		drm_crtc_send_vblank_event(crtc, crtc->state->event);
 		crtc->state->event = NULL;
 	}
+
 	spin_unlock_irq(&crtc->dev->event_lock);
+
+	/*
+	 * Stop PLL5 after stopping all target's clocks and
+	 * turn them into reset states.
+	 */
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L))
+		pll5_set_rate(0, 0, 0);
 }
 
 static void rcar_du_crtc_atomic_begin(struct drm_crtc *crtc,
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.h b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
index ded60a8..565327c 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
@@ -126,4 +126,98 @@ static inline void rcar_du_write(struct rcar_du_device *rcdu, u32 reg, u32 data)
 	iowrite32(data, rcdu->mmio + reg);
 }
 
+#define CPG_BASE			0x11010000
+
+#define CPG_PLL5_STBY			0x140
+#define CPG_PLL5_STBY_RESETB(x)		(BIT(16) | (x))
+#define CPG_PLL5_STBY_SSC_EN(x)		(BIT(18) | (x))
+#define CPG_PLL5_STBY_DOWNSPREAD(x)	(BIT(20) | (x))
+
+#define CPG_PLL5_CLK1			0x144
+#define CPG_PLL5_CLK1_POSTDIV1(x)	(BIT(16) | (x))
+#define CPG_PLL5_CLK1_POSTDIV2(x)	(BIT(20) | ((x) << 4))
+#define CPG_PLL5_CLK1_REFDIV(x)		(BIT(24) | ((x) << 8))
+
+#define CPG_PLL5_CLK3			0x14c
+#define CPG_PLL5_CLK3_DIVVAL(x)		(x)
+#define CPG_PLL5_CLK3_FRACIN(x)		((x) << 8)
+
+#define CPG_PLL5_CLK4			0x150
+#define CPG_PLL5_CLK4_INTIN(x)		((x) << 16)
+
+#define CPG_PL2_DDIV			0x204
+#define CPG_PL2_DDIV_DIVDSILPCLK_SET(x)	(BIT(28) | ((x) << 12))
+
+#define CPG_PL5_SDIV			0x420
+#define CPG_PL5_SDIV_DIVDSIA_SET(x)	(BIT(16) | (x))
+#define CPG_PL5_SDIV_DIVDSIB_SET(x)	(BIT(24) | ((x) << 8))
+
+#define FRACIN_DIV			BIT(24)
+
+#define pll5_write(a, x)		iowrite32(x, a)
+
+static inline void pll5_set_rate(unsigned long vclk, unsigned long hsclk,
+				 bool on)
+{
+	u32 postdiv1, postdiv2, refdiv;
+	u32 divval, fracin, intin;
+	u32 dsi_div_a, dsi_div_b, dsi_div;
+	u32 pll5;
+	u32 osc = 24000000;
+	u64 fracin_num;
+	bool done = false;
+	void __iomem *cpg = ioremap_nocache(CPG_BASE, 0x1000);
+
+	if (!on) {
+		pll5_write(cpg + CPG_PLL5_STBY, CPG_PLL5_STBY_RESETB(0));
+
+		return;
+	}
+	/* foutpostdiv = osc*(intin+fracin/2^24) / (refdiv*postdiv1*postdiv2)
+	 * Based on HW manual, pll5 has frequency equal to 16 times of hsclk.
+	 * Currently, we set refdiv = postdiv1 = postdiv2 = 1.
+	 * To change frequency of foutpostdiv, we just need to care about initin
+	 * and fracin coefficient.
+	 * OSC is external input clock with 24MHz.
+	 */
+	pll5 = 16 * hsclk;
+	postdiv1 = postdiv2 = refdiv = 1;
+	divval = 6;
+
+	intin = pll5 / osc;
+	fracin_num = (pll5 % osc) * FRACIN_DIV;
+	fracin = fracin_num / osc;
+	dsi_div = pll5 / vclk;
+
+	for (dsi_div_b = 0; dsi_div_b <= 15; dsi_div_b++) {
+		for (dsi_div_a = 0; dsi_div_a <= 3; dsi_div_a++) {
+			if ((dsi_div_b + 1) * (1 << dsi_div_a) == dsi_div) {
+				done = true;
+				break;
+			};
+		}
+
+		if (done)
+			break;
+	}
+
+	pll5_write(cpg + CPG_PLL5_CLK1, CPG_PLL5_CLK1_POSTDIV1(postdiv1) |
+					CPG_PLL5_CLK1_POSTDIV2(postdiv2) |
+					CPG_PLL5_CLK1_REFDIV(refdiv));
+	pll5_write(cpg + CPG_PLL5_CLK3, CPG_PLL5_CLK3_DIVVAL(divval) |
+					CPG_PLL5_CLK3_FRACIN(fracin));
+
+	pll5_write(cpg + CPG_PLL5_CLK4, CPG_PLL5_CLK4_INTIN(intin));
+
+	pll5_write(cpg + CPG_PL5_SDIV, CPG_PL5_SDIV_DIVDSIA_SET(dsi_div_a) |
+				       CPG_PL5_SDIV_DIVDSIB_SET(dsi_div_b));
+
+	/* Currently we do not support SSC and Downspread features */
+	pll5_write(cpg + CPG_PLL5_STBY, CPG_PLL5_STBY_RESETB(1) |
+					CPG_PLL5_STBY_SSC_EN(0) |
+					CPG_PLL5_STBY_DOWNSPREAD(0));
+
+	iounmap(cpg);
+}
+
 #endif /* __RCAR_DU_DRV_H__ */
diff --git a/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
index 54ba6bf..ab5a22a 100644
--- a/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
+++ b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
@@ -27,6 +27,7 @@
 
 #include "rzg2l_mipi_dsi_regs.h"
 #include "rzg2l_mipi_dsi.h"
+#include "rcar_du_drv.h"
 
 struct rzg2l_mipi_dsi {
 	struct device *dev;
@@ -139,6 +140,9 @@ static int rzg2l_mipi_dsi_startup(struct rzg2l_mipi_dsi *mipi_dsi)
 	bpp = mipi_dsi_pixel_format_to_bpp(mipi_dsi->format);
 	mipi_dsi->hsfreq = (mode->clock * bpp * 8) / (8 * mipi_dsi->lanes);
 
+	/* Set rate for PLL5 */
+	pll5_set_rate(mode->clock * 1000, mipi_dsi->hsfreq * 1000 / 8, 1);
+
 	/* Initializing DPHY before accessing LINK */
 
 	/* All DSI global operation timings are set with recommended setting */
-- 
2.7.4

