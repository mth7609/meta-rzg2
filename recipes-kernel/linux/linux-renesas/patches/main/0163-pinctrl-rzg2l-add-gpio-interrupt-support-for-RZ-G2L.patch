From a9edc8c74523275cdae06216261e16db6b4bdd0d Mon Sep 17 00:00:00 2001
From: Hien Huynh <hien.huynh.px@renesas.com>
Date: Thu, 22 Apr 2021 09:06:43 +0700
Subject: [PATCH 163/180] pinctrl: rzg2l: add gpio interrupt support for RZ/G2L

This commit is created to add gpio interrupt mode for RZ/G2L SoC:
- r9a07044l can support 123 gpios for interrupt mode.
- Not support level detection now because we can not clear interrupt
after triggering. So just support only edge detection. Will try to
improve in next some patches.

Signed-off-by: Hien Huynh <hien.huynh.px@renesas.com>
---
 drivers/pinctrl/sh-pfc/pfc-r9a07g044l.c |  56 +++++++
 drivers/pinctrl/sh-pfc/pinctrl-rzg2l.c  | 264 +++++++++++++++++++++++++++++++-
 drivers/pinctrl/sh-pfc/pinctrl-rzg2l.h  |  39 ++++-
 3 files changed, 354 insertions(+), 5 deletions(-)

diff --git a/drivers/pinctrl/sh-pfc/pfc-r9a07g044l.c b/drivers/pinctrl/sh-pfc/pfc-r9a07g044l.c
index da2ae24..c99cdc4 100644
--- a/drivers/pinctrl/sh-pfc/pfc-r9a07g044l.c
+++ b/drivers/pinctrl/sh-pfc/pfc-r9a07g044l.c
@@ -2552,6 +2552,59 @@ static const struct function_desc r9a07g044l_funcs[] = {
 		ARRAY_SIZE(r9a07g044l_eth1_groups)},
 };
 
+/* R9A07G044L support 123 interrupt input pins */
+static struct rzg2l_pin_info r9a07g044l_pin_info[] = {
+	{0, 0, 0}, {0, 1, 1},
+	{1, 0, 2}, {1, 1, 3},
+	{2, 0, 4}, {2, 1, 5},
+	{3, 0, 6}, {3, 1, 7},
+	{4, 0, 8}, {4, 1, 9},
+	{5, 0, 10}, {5, 1, 11}, {5, 2, 12},
+	{6, 0, 13}, {6, 1, 14},
+	{7, 0, 15}, {7, 1, 16}, {7, 2, 17},
+	{8, 0, 18}, {8, 1, 19}, {8, 2, 20},
+	{9, 0, 21}, {9, 1, 22},
+	{10, 0, 23}, {10, 1, 24},
+	{11, 0, 25}, {11, 1, 26},
+	{12, 0, 27}, {12, 1, 28},
+	{13, 0, 29}, {13, 1, 30}, {13, 2, 31},
+	{14, 0, 32}, {14, 1, 33},
+	{15, 0, 34}, {15, 1, 35},
+	{16, 0, 36}, {16, 1, 37},
+	{17, 0, 38}, {17, 1, 39}, {17, 2, 40},
+	{18, 0, 41}, {18, 1, 42},
+	{19, 0, 43}, {19, 1, 44},
+	{20, 0, 45}, {20, 1, 46}, {20, 2, 47},
+	{21, 0, 48}, {21, 1, 49},
+	{22, 0, 50}, {22, 1, 51},
+	{23, 0, 52}, {23, 1, 53},
+	{24, 0, 54}, {24, 1, 55},
+	{25, 0, 56}, {25, 1, 57},
+	{26, 0, 58}, {26, 1, 59},
+	{27, 0, 60}, {27, 1, 61},
+	{28, 0, 62}, {28, 1, 63},
+	{29, 0, 64}, {29, 1, 65},
+	{30, 0, 66}, {30, 1, 67},
+	{31, 0, 68}, {31, 1, 69},
+	{32, 0, 70}, {32, 1, 71},
+	{33, 0, 72}, {33, 1, 73},
+	{34, 0, 74}, {34, 1, 75},
+	{35, 0, 76}, {35, 1, 77},
+	{36, 0, 78}, {36, 1, 79},
+	{37, 0, 80}, {37, 1, 81}, {37, 2, 82},
+	{38, 0, 83}, {38, 1, 84},
+	{39, 0, 85}, {39, 1, 86}, {39, 2, 87},
+	{40, 0, 88}, {40, 1, 89}, {40, 2, 90},
+	{41, 0, 91}, {41, 1, 92},
+	{42, 0, 93}, {42, 1, 94}, {42, 2, 95}, {42, 3, 96}, {42, 4, 97},
+	{43, 0, 98}, {43, 1, 99}, {43, 2, 100}, {43, 3, 101},
+	{44, 0, 102}, {44, 1, 103}, {44, 2, 104}, {44, 3, 105},
+	{45, 0, 106}, {45, 1, 107}, {45, 2, 108}, {45, 3, 109},
+	{46, 0, 110}, {46, 1, 111}, {46, 2, 112}, {46, 3, 113},
+	{47, 0, 114}, {47, 1, 115}, {47, 2, 116}, {47, 3, 117},
+	{48, 0, 118}, {48, 1, 119}, {48, 2, 120}, {48, 3, 121}, {48, 3, 122},
+};
+
 const struct rzg2l_pin_soc r9a07g044l_pinctrl_data = {
 	.pins =	r9a07g044l_pins.pin_gpio,
 	.npins = ARRAY_SIZE(r9a07g044l_pins.pin_gpio) +
@@ -2561,4 +2614,7 @@ const struct rzg2l_pin_soc r9a07g044l_pinctrl_data = {
 	.funcs = r9a07g044l_funcs,
 	.nfuncs	= ARRAY_SIZE(r9a07g044l_funcs),
 	.nports = 49,
+	.nirqs = 32,
+	.pin_info = r9a07g044l_pin_info,
+	.ngpioints = ARRAY_SIZE(r9a07g044l_pin_info),
 };
diff --git a/drivers/pinctrl/sh-pfc/pinctrl-rzg2l.c b/drivers/pinctrl/sh-pfc/pinctrl-rzg2l.c
index f01c4f5..e1f4b50 100644
--- a/drivers/pinctrl/sh-pfc/pinctrl-rzg2l.c
+++ b/drivers/pinctrl/sh-pfc/pinctrl-rzg2l.c
@@ -12,6 +12,8 @@
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
 
 #include "pinctrl-rzg2l.h"
 
@@ -591,6 +593,198 @@ static int rzg2l_pinctrl_add_functions(struct rzg2l_pinctrl *pctrl)
 	return 0;
 }
 
+static int rzg2l_gpio_irq_validate_id(struct rzg2l_pinctrl *pctrl, u32 port,
+				      u32 bit)
+{
+	const struct rzg2l_pin_info *pin_info = pctrl->psoc->pin_info;
+	int i;
+
+	for (i = 0; i <= pctrl->psoc->ngpioints; i++) {
+		if (port == pin_info->port && bit == pin_info->bit)
+			return pin_info->gpio_irq_id;
+
+		pin_info++;
+	}
+
+	return i;
+}
+
+static int rzg2l_gpio_irq_request_tint_slot(struct rzg2l_pinctrl *pctrl)
+{
+	int i;
+
+	for (i = 0; i <= pctrl->psoc->nirqs; i++) {
+		if (pctrl->tint[i] == 0)
+			break;
+	}
+
+	return i;
+}
+
+static int rzg2l_gpio_irq_check_tint_slot(struct rzg2l_pinctrl *pctrl,
+					  u32 gpio_id)
+{
+	int i;
+
+	for (i = 0; i <= pctrl->psoc->nirqs; i++) {
+		if (pctrl->tint[i] == (BIT(16) | gpio_id))
+			break;
+	}
+
+	return i;
+}
+
+static void rzg2l_gpio_irq_disable(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+	struct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);
+	int hw_irq = irqd_to_hwirq(d);
+	u32 port = RZG2L_PIN_ID_TO_PORT(hw_irq);
+	u8 bit = RZG2L_PIN_ID_TO_PIN(hw_irq);
+	u32 gpioint;
+	u32 tint_slot;
+	unsigned long flags;
+	u64 reg64;
+	u32 reg32;
+
+	gpioint = rzg2l_gpio_irq_validate_id(pctrl, port, bit);
+	if (gpioint == pctrl->psoc->ngpioints)
+		return;
+
+	tint_slot = rzg2l_gpio_irq_check_tint_slot(pctrl, gpioint);
+	if (tint_slot ==  pctrl->psoc->nirqs)
+		return;
+
+
+	spin_lock_irqsave(&pctrl->lock, flags);
+
+	reg64 = readq(pctrl->base + ISEL(port));
+	reg64 &= ~BIT(bit * 8);
+	writeq(reg64, pctrl->base + ISEL(port));
+
+	reg32 = readl(pctrl->base_tint + TSSR(tint_slot / 4));
+	reg32 &= ~(GENMASK(7, 0) << (tint_slot % 4));
+	writel(reg32, pctrl->base_tint + TSSR(tint_slot / 4));
+
+	spin_unlock_irqrestore(&pctrl->lock, flags);
+
+	pctrl->tint[tint_slot] = 0;
+}
+
+static void rzg2l_gpio_irq_enable(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+	struct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);
+	int hw_irq = irqd_to_hwirq(d);
+	u32 port = RZG2L_PIN_ID_TO_PORT(hw_irq);
+	u8 bit = RZG2L_PIN_ID_TO_PIN(hw_irq);
+	u32 gpioint;
+	u32 tint_slot;
+	unsigned long flags;
+	u64 reg64;
+	u32 reg32;
+
+	gpioint = rzg2l_gpio_irq_validate_id(pctrl, port, bit);
+	if (gpioint == pctrl->psoc->ngpioints)
+		return;
+
+	tint_slot = rzg2l_gpio_irq_check_tint_slot(pctrl, hw_irq);
+	if (tint_slot ==  pctrl->psoc->nirqs)
+		return;
+
+	spin_lock_irqsave(&pctrl->lock, flags);
+
+	reg64 = readq(pctrl->base + ISEL(port));
+	reg64 |= BIT(bit * 8);
+	writeq(reg64, pctrl->base + ISEL(port));
+
+	reg32 = readl(pctrl->base_tint + TSSR(tint_slot / 4));
+	reg32 |= (BIT(7) | gpioint) << (8 * (tint_slot % 4));
+	writel(reg32, pctrl->base_tint + TSSR(tint_slot / 4));
+
+	spin_unlock_irqrestore(&pctrl->lock, flags);
+}
+
+static int rzg2l_gpio_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+	struct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);
+	int hw_irq = irqd_to_hwirq(d);
+	u32 port = RZG2L_PIN_ID_TO_PORT(hw_irq);
+	u8 bit = RZG2L_PIN_ID_TO_PIN(hw_irq);
+	u32 gpioint;
+	u32 tint_slot;
+	unsigned long flags;
+	u32 irq_type;
+	u32 reg32;
+	u8 reg8;
+
+	gpioint = rzg2l_gpio_irq_validate_id(pctrl, port, bit);
+	if (gpioint == pctrl->psoc->ngpioints)
+		return -EINVAL;
+
+
+	tint_slot = rzg2l_gpio_irq_request_tint_slot(pctrl);
+	if (tint_slot ==  pctrl->psoc->nirqs)
+		return -EINVAL;
+
+	switch (type & IRQ_TYPE_SENSE_MASK) {
+	/*
+	 * Currently we just support interrupt edge type.
+	 * About level type, we do not support because we can not clear
+	 * after triggering.
+	 */
+	case IRQ_TYPE_EDGE_RISING:
+		irq_type = RISING_EDGE;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		irq_type = FALLING_EDGE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&pctrl->lock, flags);
+
+	/* Select GPIO mode in PMC Register before enabling interrupt mode */
+	reg8 = readb(pctrl->base + PMC(port));
+	reg8 &= ~BIT(bit);
+	writeb(reg8, pctrl->base + PMC(port));
+
+	pctrl->tint[tint_slot] = BIT(16) | hw_irq;
+
+	if (tint_slot > 15) {
+		reg32 = readl(pctrl->base_tint + TITSR1);
+		reg32 &= ~(IRQ_MASK << (tint_slot * 2));
+		reg32 |= irq_type << (tint_slot * 2);
+		writel(reg32, pctrl->base_tint + TITSR1);
+	} else {
+		reg32 = readl(pctrl->base_tint + TITSR0);
+		reg32 &= ~(IRQ_MASK << ((tint_slot - 16) * 2));
+		reg32 |= irq_type << ((tint_slot - 16) * 2);
+		writel(reg32, pctrl->base_tint + TITSR0);
+	}
+
+	spin_unlock_irqrestore(&pctrl->lock, flags);
+
+	return 0;
+}
+
+static irqreturn_t rzg2l_pinctrl_irq_handler(int irq, void *dev_id)
+{
+	struct rzg2l_pinctrl *pctrl = dev_id;
+	unsigned int offset = irq - pctrl->irq_start;
+	u32 reg32;
+
+	reg32 = readl(pctrl->base_tint + TSCR);
+	writel(reg32 & ~BIT(offset), pctrl->base_tint + TSCR);
+
+	generic_handle_irq(irq_find_mapping(pctrl->gpio_chip.irq.domain,
+					    pctrl->tint[offset] & ~BIT(16)));
+
+	return IRQ_HANDLED;
+}
+
 static int rzg2l_gpio_request(struct gpio_chip *chip, unsigned int offset)
 {
 	struct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);
@@ -648,12 +842,14 @@ static int rzg2l_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
 
 		reg16 = readw(pctrl->base + PM(port));
 		reg16 = (reg16 >> (bit * 2)) & PM_MASK;
-		if (reg16 == PM_OUTPUT || reg16 == PM_OUTPUT_INPUT)
+		if (reg16 == PM_OUTPUT)
 			return GPIOF_OUTPUT;
 		else if (reg16 == PM_INPUT)
 			return GPIOF_INPUT;
+		else if (reg16 == PM_OUTPUT_INPUT)
+			return GPIOF_BIDIRECTION;
 		else
-			return -EINVAL;
+			return GPIOF_HI_Z;
 	} else {
 		return -EINVAL;
 	}
@@ -738,10 +934,12 @@ static void rzg2l_gpio_free(struct gpio_chip *chip, unsigned int offset)
 static int rzg2l_pinctrl_add_gpiochip(struct rzg2l_pinctrl *pctrl)
 {
 	struct gpio_chip *chip = &pctrl->gpio_chip;
+	struct irq_chip *irq_chip = &pctrl->irq_chip;
 	struct device_node *np = pctrl->dev->of_node;
 	struct of_phandle_args args;
 	int ret;
 	unsigned int npins;
+	const char *name = dev_name(pctrl->dev);
 
 	ret = of_parse_phandle_with_fixed_args(np, "gpio-ranges", 3, 0, &args);
 	if (ret) {
@@ -751,7 +949,7 @@ static int rzg2l_pinctrl_add_gpiochip(struct rzg2l_pinctrl *pctrl)
 
 	npins = args.args[2];
 
-	chip->label = dev_name(pctrl->dev);
+	chip->label = name;
 	chip->parent = pctrl->dev;
 	chip->base = -1;
 	chip->ngpio = npins;
@@ -764,20 +962,34 @@ static int rzg2l_pinctrl_add_gpiochip(struct rzg2l_pinctrl *pctrl)
 	chip->free = rzg2l_gpio_free;
 	chip->owner = THIS_MODULE;
 
+	irq_chip->name = name;
+	irq_chip->irq_disable = rzg2l_gpio_irq_disable;
+	irq_chip->irq_enable = rzg2l_gpio_irq_enable;
+	irq_chip->irq_set_type = rzg2l_gpio_irq_set_type;
+	irq_chip->flags = IRQCHIP_SET_TYPE_MASKED;
+
 	ret = devm_gpiochip_add_data(pctrl->dev, chip, pctrl);
 	if (ret) {
 		dev_err(pctrl->dev, "failed to add GPIO controller\n");
 		return ret;
 	}
 
+	ret = gpiochip_irqchip_add(chip, irq_chip, 0, handle_level_irq,
+				   IRQ_TYPE_NONE);
+	if (ret) {
+		dev_err(pctrl->dev, "cannot add irqchip\n");
+		return ret;
+	}
+
 	return 0;
 }
 
 static int rzg2l_pinctrl_probe(struct platform_device *pdev)
 {
-	struct resource *res;
+	struct resource *res, *irq;
 	struct rzg2l_pinctrl *pctrl;
 	const struct rzg2l_pin_soc *psoc;
+	int i;
 	int ret;
 
 	psoc = of_device_get_match_data(&pdev->dev);
@@ -800,6 +1012,16 @@ static int rzg2l_pinctrl_probe(struct platform_device *pdev)
 	if (IS_ERR(pctrl->base))
 		return PTR_ERR(pctrl->base);
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&pdev->dev, "missing IO resource\n");
+		return -ENXIO;
+	}
+
+	pctrl->base_tint = ioremap_nocache(res->start, resource_size(res));
+	if (IS_ERR(pctrl->base_tint))
+		return PTR_ERR(pctrl->base_tint);
+
 	spin_lock_init(&pctrl->lock);
 
 	pctrl->pctrl_desc.name = DRV_NAME;
@@ -848,12 +1070,45 @@ static int rzg2l_pinctrl_probe(struct platform_device *pdev)
 		return ret;
 	};
 
+	for (i = 0; i < psoc->nirqs; i++) {
+		char *irqstr[psoc->nirqs];
+
+		irq = platform_get_resource(pdev, IORESOURCE_IRQ, i);
+		if (!irq) {
+			dev_err(pctrl->dev, "missing IRQ\n");
+			return -EINVAL;
+		};
+
+		if (i == 0)
+			pctrl->irq_start = irq->start;
+
+		irqstr[i] = kasprintf(GFP_KERNEL, "tint%d", i);
+
+		if (devm_request_irq(pctrl->dev, irq->start,
+				     rzg2l_pinctrl_irq_handler, IRQF_SHARED,
+				     irqstr[i], pctrl)) {
+			dev_err(pctrl->dev, "failed to request IRQ\n");
+			return -ENOENT;
+		}
+	}
+
 	platform_set_drvdata(pdev, pctrl);
 
 	dev_info(pctrl->dev, "%s support registered\n", DRV_NAME);
 	return 0;
 }
 
+static int rzg2l_pinctrl_remove(struct platform_device *pdev)
+{
+	struct rzg2l_pinctrl *pctrl = platform_get_drvdata(pdev);
+
+	gpiochip_remove(&pctrl->gpio_chip);
+
+	iounmap(pctrl->base_tint);
+
+	return 0;
+}
+
 static const struct of_device_id rzg2l_pinctrl_of_table[] = {
 #ifdef CONFIG_PINCTRL_R9A07G044L
 	{
@@ -870,6 +1125,7 @@ static struct platform_driver rzg2l_pinctrl_driver = {
 		.of_match_table = of_match_ptr(rzg2l_pinctrl_of_table),
 	},
 	.probe = rzg2l_pinctrl_probe,
+	.remove = rzg2l_pinctrl_remove,
 };
 
 static int __init rzg2l_pinctrl_init(void)
diff --git a/drivers/pinctrl/sh-pfc/pinctrl-rzg2l.h b/drivers/pinctrl/sh-pfc/pinctrl-rzg2l.h
index c9744730..ae211f4 100644
--- a/drivers/pinctrl/sh-pfc/pinctrl-rzg2l.h
+++ b/drivers/pinctrl/sh-pfc/pinctrl-rzg2l.h
@@ -18,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/clk.h>
+#include <linux/reset.h>
 #include <linux/phy.h>
 
 #include "../core.h"
@@ -29,7 +30,7 @@
 #define PMC(n)	(0x0200 + 0x10 + (n))     /* Port Mode Control Register */
 #define PFC(n)	(0x0400 + 0x40 + (n) * 4) /* Port Function Control Register */
 #define PIN(n)	(0x0800 + 0x10 + (n))     /* Port Input Register */
-#define PFC(n)	(0x0400 + 0x40 + (n) * 4) /* Port Function Control Register */
+#define ISEL(n)	(0x2C00 + 0x80 + (n) * 8) /* IRQ Enable Control Register */
 #define PWPR	(0x3014)                  /* Port Write Protection Register */
 
 #define IOLH(n) (0x1000 + (n) * 8)	/* IOLH Switch Register */
@@ -81,6 +82,28 @@
 
 #define GPIOF_OUTPUT			0
 #define GPIOF_INPUT			1
+#define GPIOF_BIDIRECTION		2
+#define GPIOF_HI_Z			3
+
+/* Hardware Registers support GPIO interrupt in IA55 Module */
+#define TSCR	0x0		/* TINT Interrupt Status Control Register */
+#define TITSR0	0x4		/* TINT detection method selection register 0 */
+#define TITSR1	0x8		/* TINT detection method selection register 1 */
+#define TSSR(n)	(0x10 + (n) * 4) /* TINT source selection register */
+
+#define RISING_EDGE	0
+#define FALLING_EDGE	1
+#define HIGH_LEVEL	2
+#define LOW_LEVEL	3
+#define IRQ_MASK	0x3
+
+#define TINT_MAX	32
+
+struct rzg2l_pin_info {
+	u32 port;		/* Store port position of a pin */
+	u32 bit;		/* Store bit position of a pin */
+	u32 gpio_irq_id;	/* Store interrupt id for a pin */
+};
 
 struct rzg2l_pin_soc {
 	const struct pinctrl_pin_desc	*pins;
@@ -91,6 +114,10 @@ struct rzg2l_pin_soc {
 	unsigned int			nfuncs;
 
 	unsigned int			nports;
+
+	unsigned int			nirqs;
+	const struct rzg2l_pin_info	*pin_info;
+	unsigned int			ngpioints;
 };
 
 struct pin_data {
@@ -104,16 +131,26 @@ struct rzg2l_pinctrl {
 	struct pinctrl_desc		pctrl_desc;
 
 	void __iomem			*base;
+	void __iomem			*base_tint;
 	struct device			*dev;
 	struct clk			*clk;
 
 	struct gpio_chip		gpio_chip;
+	struct irq_chip			irq_chip;
 
 	const struct rzg2l_pin_soc	*psoc;
 
 	spinlock_t			lock;
 
 	unsigned int			nports;
+
+	unsigned int			irq_start;
+
+	/* This array will store GPIO IDs for TINT[0-32] with value:
+	 * - [15-0] bits: store GPIO IDs (ID = port * 8 + bit).
+	 * - [16] bit: store active status (1 for enabled, 0 for disabled).
+	 */
+	u32				tint[TINT_MAX];
 };
 
 #define RZ_G2L_PINCTRL_PIN_GPIO(port, configs)			\
-- 
2.7.4

